name: Automated Deployment Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (manual override)'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - staging
        - production
      skip_validation:
        description: 'Skip staging validation for production deployment'
        required: false
        default: false
        type: boolean

env:
  STAGING_URL: ${{ secrets.STAGING_URL }}
  PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  validate:
    name: 'Code Validation'
    runs-on: ubuntu-latest
    outputs:
      validation_passed: ${{ steps.validation.outputs.passed }}
      coverage: ${{ steps.validation.outputs.coverage }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: pip install -r requirements.txt

    - name: Run tests
      run: |
        pytest tests/ -v --tb=short --durations=10 --maxfail=5

    - name: Run security scan
      run: |
        pip install safety
        safety check --bare --output json > security-report.json || true

    - name: Validate deployment readiness
      id: validation
      run: |
        # Check for critical files
        if [ ! -f "app.py" ] || [ ! -f "requirements.txt" ]; then
          echo "âŒ Critical files missing"
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Check Python syntax
        python -m py_compile app.py
        python -c "import agents.models, agents.runtime, services.persist" || exit 1

        # Check test coverage
        pytest --cov=agents --cov=services --cov-report=xml --cov-report=term
        COVERAGE=$(python -c "
        import xml.etree.ElementTree as ET
        root = ET.parse('coverage.xml').getroot()
        coverage = float(root.get('line-rate', 0)) * 100
        print(f'{coverage:.1f}')
        ")

        if (( $(echo "$COVERAGE < 85" | bc -l) )); then
          echo "âŒ Coverage $COVERAGE% below 85% threshold"
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "âœ… Validation passed (Coverage: $COVERAGE%)"
        echo "passed=true" >> $GITHUB_OUTPUT
        echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT

  build:
    name: 'Build & Package'
    needs: validate
    if: needs.validate.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      deployment_archive: ${{ steps.build.outputs.deployment_archive }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ secrets.CONTAINER_REGISTRY }}
        username: ${{ secrets.CONTAINER_USERNAME }}
        password: ${{ secrets.CONTAINER_PASSWORD }}

    - name: Build and push Docker image
      id: build
      run: |
        IMAGE_TAG="${{ secrets.CONTAINER_REGISTRY }}/agent-lab:${{ github.sha }}"
        echo "Building Docker image: $IMAGE_TAG"

        docker build -t $IMAGE_TAG .
        docker push $IMAGE_TAG

        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

        # Create deployment archive for backup
        mkdir -p deployment
        cp -r * deployment/
        cd deployment

        # Remove development files
        rm -rf .git __pycache__ .pytest_cache tests/ .github/

        # Create deployment archive
        ARCHIVE_NAME="agent-lab-deployment-${{ github.sha }}.tar.gz"
        tar -czf ../$ARCHIVE_NAME .
        cd ..
        echo "deployment_archive=$ARCHIVE_NAME" >> $GITHUB_OUTPUT

    - name: Upload deployment artifact
      uses: actions/upload-artifact@v4
      with:
        name: deployment-archive-${{ github.sha }}
        path: ${{ steps.build.outputs.deployment_archive }}
        retention-days: 30

  deploy_staging:
    name: 'Deploy to Staging'
    needs: [validate, build]
    if: needs.validate.outputs.validation_passed == 'true' && (github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging' || github.event.inputs.environment == 'auto')
    runs-on: ubuntu-latest
    environment: staging
    outputs:
      staging_validation_passed: ${{ steps.staging_validation.outputs.passed }}

    steps:
    - uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        echo "ðŸš€ Deploying to staging environment..."
        echo "Image: ${{ needs.build.outputs.image_tag }}"

        # Deploy to staging environment
        # Replace with your actual deployment commands
        # Examples: kubectl, docker-compose, AWS ECS, etc.

        echo "ðŸ“¦ Deploying image: ${{ needs.build.outputs.image_tag }}"
        echo "ðŸŒ Environment: staging"

        # Simulate deployment
        echo "âœ… Staging deployment completed"

    - name: Wait for staging deployment
      run: sleep 60

    - name: Validate staging deployment
      id: staging_validation
      run: |
        echo "ðŸ” Validating staging deployment..."

        # Health check
        if [ -n "$STAGING_URL" ]; then
          echo "Checking health endpoint: $STAGING_URL/health"
          # curl -f --max-time 30 $STAGING_URL/health || exit 1
          echo "âœ… Health check passed"
        else
          echo "âš ï¸  No staging URL configured, skipping health check"
        fi

        # Basic functionality test
        python -c "
        import sys
        try:
          import app
          print('âœ… Application imports successfully')
        except Exception as e:
          print(f'âŒ Application import failed: {e}')
          sys.exit(1)
        "

        echo "passed=true" >> $GITHUB_OUTPUT

    - name: Notify staging deployment
      if: success()
      run: |
        MESSAGE="âœ… Staging deployment successful
        Commit: ${{ github.sha }}
        Coverage: ${{ needs.validate.outputs.coverage }}%
        URL: $STAGING_URL"

        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\"}" \
            $SLACK_WEBHOOK
        fi

  deploy_production:
    name: 'Deploy to Production'
    needs: [validate, build, deploy_staging]
    if: >
      needs.validate.outputs.validation_passed == 'true' &&
      (needs.deploy_staging.outputs.staging_validation_passed == 'true' || github.event.inputs.skip_validation == 'true') &&
      (github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production')
    runs-on: ubuntu-latest
    environment: production
    outputs:
      production_validation_passed: ${{ steps.production_validation.outputs.passed }}

    steps:
    - uses: actions/checkout@v4

    - name: Create pre-deployment backup
      run: |
        echo "ðŸ’¾ Creating pre-deployment backup..."

        # Backup current production data
        # Replace with your actual backup commands
        echo "âœ… Pre-deployment backup completed"

    - name: Deploy to production
      run: |
        echo "ðŸš€ Deploying to production environment..."
        echo "Image: ${{ needs.build.outputs.image_tag }}"

        # Blue-green deployment to production
        echo "ðŸ”„ Starting blue-green deployment..."

        # Deploy new version alongside current
        echo "ðŸ“¦ Deploying new version: ${{ needs.build.outputs.image_tag }}"

        # Run smoke tests on new version
        echo "ðŸ§ª Running smoke tests on new version..."

        # Switch traffic to new version
        echo "ðŸ”€ Switching traffic to new version..."

        echo "âœ… Production deployment completed"

    - name: Wait for production deployment
      run: sleep 120

    - name: Validate production deployment
      id: production_validation
      run: |
        echo "ðŸ” Validating production deployment..."

        # Health check
        if [ -n "$PRODUCTION_URL" ]; then
          echo "Checking health endpoint: $PRODUCTION_URL/health"
          # curl -f --max-time 30 $PRODUCTION_URL/health || exit 1
          echo "âœ… Health check passed"
        else
          echo "âš ï¸  No production URL configured, skipping health check"
        fi

        # Data integrity check
        echo "ðŸ“Š Verifying data integrity..."

        # Performance validation
        echo "âš¡ Running performance validation..."

        echo "passed=true" >> $GITHUB_OUTPUT

    - name: Notify production deployment success
      if: success()
      run: |
        MESSAGE="ðŸŽ‰ Production deployment successful!
        Commit: ${{ github.sha }}
        Coverage: ${{ needs.validate.outputs.coverage }}%
        URL: $PRODUCTION_URL
        Staging validation: âœ… Passed"

        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\"}" \
            $SLACK_WEBHOOK
        fi

  create_deployment_record:
    name: 'Create Deployment Record'
    needs: [validate, build, deploy_staging, deploy_production]
    if: always()
    runs-on: ubuntu-latest

    steps:
    - name: Create deployment record
      run: |
        cat > deployment_record.json << EOF
        {
          "deployment_id": "${{ github.run_id }}",
          "timestamp": "$(date -Iseconds)",
          "commit_sha": "${{ github.sha }}",
          "trigger": "${{ github.event_name }}",
          "validation_passed": "${{ needs.validate.outputs.validation_passed }}",
          "coverage": "${{ needs.validate.outputs.coverage }}%",
          "staging_deployed": "${{ needs.deploy_staging.result }}",
          "staging_validation_passed": "${{ needs.deploy_staging.outputs.staging_validation_passed }}",
          "production_deployed": "${{ needs.deploy_production.result }}",
          "production_validation_passed": "${{ needs.deploy_production.outputs.production_validation_passed }}",
          "image_tag": "${{ needs.build.outputs.image_tag }}",
          "deployment_archive": "${{ needs.build.outputs.deployment_archive }}"
        }
        EOF

    - name: Upload deployment record
      uses: actions/upload-artifact@v4
      with:
        name: deployment-record-${{ github.run_id }}
        path: deployment_record.json
        retention-days: 90

  rollback:
    name: 'Rollback'
    needs: [deploy_production]
    if: failure() && (needs.deploy_production.result == 'failure')
    runs-on: ubuntu-latest
    environment: production

    steps:
    - name: Trigger rollback
      run: |
        echo "âŒ Production deployment failed, initiating rollback..."

        # Identify rollback target
        echo "ðŸ” Finding previous stable deployment..."

        # Execute rollback
        echo "ðŸ”„ Rolling back to previous version..."

        # Replace with your actual rollback commands
        # Examples: kubectl rollout undo, docker service rollback, etc.

        echo "âœ… Rollback completed"

    - name: Validate rollback
      run: |
        echo "ðŸ” Validating rollback..."

        # Health checks after rollback
        if [ -n "$PRODUCTION_URL" ]; then
          # curl -f --max-time 30 $PRODUCTION_URL/health || exit 1
          echo "âœ… Rollback health check passed"
        fi

    - name: Notify rollback
      run: |
        MESSAGE="ðŸš¨ Production deployment failed and was rolled back
        Commit: ${{ github.sha }}
        Deployment ID: ${{ github.run_id }}
        Check logs for details"

        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$MESSAGE\"}" \
            $SLACK_WEBHOOK
        fi